

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.core.fromnumeric &mdash; cvopt  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="cvopt  documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> cvopt
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/cvopt.model_selection.html">cvopt.model_selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/cvopt.search_setting.html">cvopt.search_setting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/cvopt.utils.html">cvopt.utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cvopt</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>numpy.core.fromnumeric</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.core.fromnumeric</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module containing non-deprecated functions borrowed from Numeric.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">VisibleDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">multiarray</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">umath</span> <span class="k">as</span> <span class="n">um</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">numerictypes</span> <span class="k">as</span> <span class="n">nt</span>
<span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_methods</span>


<span class="n">_dt_</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">sctype2char</span>

<span class="c1"># functions that are methods</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;alen&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;alltrue&#39;</span><span class="p">,</span> <span class="s1">&#39;amax&#39;</span><span class="p">,</span> <span class="s1">&#39;amin&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;argmax&#39;</span><span class="p">,</span>
    <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="s1">&#39;argpartition&#39;</span><span class="p">,</span> <span class="s1">&#39;argsort&#39;</span><span class="p">,</span> <span class="s1">&#39;around&#39;</span><span class="p">,</span> <span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span> <span class="s1">&#39;cumproduct&#39;</span><span class="p">,</span> <span class="s1">&#39;cumsum&#39;</span><span class="p">,</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="s1">&#39;nonzero&#39;</span><span class="p">,</span> <span class="s1">&#39;partition&#39;</span><span class="p">,</span> <span class="s1">&#39;prod&#39;</span><span class="p">,</span> <span class="s1">&#39;product&#39;</span><span class="p">,</span> <span class="s1">&#39;ptp&#39;</span><span class="p">,</span> <span class="s1">&#39;put&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;ravel&#39;</span><span class="p">,</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;resize&#39;</span><span class="p">,</span> <span class="s1">&#39;round_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;searchsorted&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;sometrue&#39;</span><span class="p">,</span> <span class="s1">&#39;sort&#39;</span><span class="p">,</span> <span class="s1">&#39;squeeze&#39;</span><span class="p">,</span>
    <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="s1">&#39;take&#39;</span><span class="p">,</span> <span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;transpose&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="n">_gentype</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span>
<span class="c1"># save away Python sum</span>
<span class="n">_sum_</span> <span class="o">=</span> <span class="nb">sum</span>


<span class="c1"># functions that are now methods</span>
<span class="k">def</span> <span class="nf">_wrapit</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">wrap</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__array_wrap__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">wrap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_wrapfunc</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c1"># An AttributeError occurs if the object does not have</span>
    <span class="c1"># such a method in its class.</span>

    <span class="c1"># A TypeError occurs if the object does have such a method</span>
    <span class="c1"># in its class, but its signature is not identical to that</span>
    <span class="c1"># of NumPy&#39;s. This situation has occurred in the case of</span>
    <span class="c1"># a downstream library like &#39;pandas&#39;.</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take elements from an array along an axis.</span>

<span class="sd">    When axis is not None, this function does the same thing as &quot;fancy&quot;</span>
<span class="sd">    indexing (indexing arrays using arrays); however, it can be easier to use</span>
<span class="sd">    if you need elements along a given axis. A call such as</span>
<span class="sd">    ``np.take(arr, indices, axis=3)`` is equivalent to</span>
<span class="sd">    ``arr[:,:,:,indices,...]``.</span>

<span class="sd">    Explained without fancy indexing, this is equivalent to the following use</span>
<span class="sd">    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of</span>
<span class="sd">    indices::</span>

<span class="sd">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span>
<span class="sd">        Nj = indices.shape</span>
<span class="sd">        for ii in ndindex(Ni):</span>
<span class="sd">            for jj in ndindex(Nj):</span>
<span class="sd">                for kk in ndindex(Nk):</span>
<span class="sd">                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like (Ni..., M, Nk...)</span>
<span class="sd">        The source array.</span>
<span class="sd">    indices : array_like (Nj...)</span>
<span class="sd">        The indices of the values to extract.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">        Also allow scalars for indices.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis over which to select values. By default, the flattened</span>
<span class="sd">        input array is used.</span>
<span class="sd">    out : ndarray, optional (Ni..., Nj..., Nk...)</span>
<span class="sd">        If provided, the result will be placed in this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; -- raise an error (default)</span>
<span class="sd">        * &#39;wrap&#39; -- wrap around</span>
<span class="sd">        * &#39;clip&#39; -- clip to the range</span>

<span class="sd">        &#39;clip&#39; mode means that all indices that are too large are replaced</span>
<span class="sd">        by the index that addresses the last element along that axis. Note</span>
<span class="sd">        that this disables indexing with negative numbers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray (Ni..., Nj..., Nk...)</span>
<span class="sd">        The returned array has the same type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compress : Take elements using a boolean mask</span>
<span class="sd">    ndarray.take : equivalent method</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    By eliminating the inner loop in the description above, and using `s_` to</span>
<span class="sd">    build simple slice objects, `take` can be expressed  in terms of applying</span>
<span class="sd">    fancy indexing to each 1-d slice::</span>

<span class="sd">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span>
<span class="sd">        for ii in ndindex(Ni):</span>
<span class="sd">            for kk in ndindex(Nj):</span>
<span class="sd">                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]</span>

<span class="sd">    For this reason, it is equivalent to (but faster than) the following use</span>
<span class="sd">    of `apply_along_axis`::</span>

<span class="sd">        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = [4, 3, 5, 7, 6, 8]</span>
<span class="sd">    &gt;&gt;&gt; indices = [0, 1, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.take(a, indices)</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    In this example if `a` is an ndarray, &quot;fancy&quot; indexing can be used.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array(a)</span>
<span class="sd">    &gt;&gt;&gt; a[indices]</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    If `indices` is not one dimensional, the output also has these dimensions.</span>

<span class="sd">    &gt;&gt;&gt; np.take(a, [[0, 1], [2, 3]])</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [5, 7]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;take&#39;</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="c1"># not deprecated --- copy if necessary, view otherwise</span>
<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a new shape to an array without changing its data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be reshaped.</span>
<span class="sd">    newshape : int or tuple of ints</span>
<span class="sd">        The new shape should be compatible with the original shape. If</span>
<span class="sd">        an integer, then the result will be a 1-D array of that length.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;}, optional</span>
<span class="sd">        Read the elements of `a` using this index order, and place the</span>
<span class="sd">        elements into the reshaped array using this index order.  &#39;C&#39;</span>
<span class="sd">        means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first</span>
<span class="sd">        axis index changing slowest. &#39;F&#39; means to read / write the</span>
<span class="sd">        elements using Fortran-like index order, with the first index</span>
<span class="sd">        changing fastest, and the last index changing slowest. Note that</span>
<span class="sd">        the &#39;C&#39; and &#39;F&#39; options take no account of the memory layout of</span>
<span class="sd">        the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        &#39;A&#39; means to read / write the elements in Fortran-like index</span>
<span class="sd">        order if `a` is Fortran *contiguous* in memory, C-like order</span>
<span class="sd">        otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reshaped_array : ndarray</span>
<span class="sd">        This will be a new view object if possible; otherwise, it will</span>
<span class="sd">        be a copy.  Note there is no guarantee of the *memory layout* (C- or</span>
<span class="sd">        Fortran- contiguous) of the returned array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.reshape : Equivalent method.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is not always possible to change the shape of an array without</span>
<span class="sd">    copying the data. If you want an error to be raised when the data is copied,</span>
<span class="sd">    you should assign the new shape to the shape attribute of the array::</span>

<span class="sd">     &gt;&gt;&gt; a = np.zeros((10, 2))</span>
<span class="sd">     # A transpose makes the array non-contiguous</span>
<span class="sd">     &gt;&gt;&gt; b = a.T</span>
<span class="sd">     # Taking a view makes it possible to modify the shape without modifying</span>
<span class="sd">     # the initial object.</span>
<span class="sd">     &gt;&gt;&gt; c = b.view()</span>
<span class="sd">     &gt;&gt;&gt; c.shape = (20)</span>
<span class="sd">     AttributeError: incompatible shape for a non-contiguous array</span>

<span class="sd">    The `order` keyword gives the index ordering both for *fetching* the values</span>
<span class="sd">    from `a`, and then *placing* the values into the output array.</span>
<span class="sd">    For example, let&#39;s say you have an array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    You can think of reshaping as first raveling the array (using the given</span>
<span class="sd">    index order), then inserting the elements from the raveled array into the</span>
<span class="sd">    new array using the same kind of index ordering as was used for the</span>
<span class="sd">    raveling.</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3), order=&#39;F&#39;) # Fortran-like index ordering</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a, order=&#39;F&#39;), (2, 3), order=&#39;F&#39;)</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6, order=&#39;F&#39;)</span>
<span class="sd">    array([1, 4, 2, 5, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array from an index array and a set of arrays to choose from.</span>

<span class="sd">    First of all, if confused or uncertain, definitely look at the Examples -</span>
<span class="sd">    in its full generality, this function is less simple than it might</span>
<span class="sd">    seem from the following code description (below ndi =</span>
<span class="sd">    `numpy.lib.index_tricks`):</span>

<span class="sd">    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.</span>

<span class="sd">    But this omits some subtleties.  Here is a fully general summary:</span>

<span class="sd">    Given an &quot;index&quot; array (`a`) of integers and a sequence of `n` arrays</span>
<span class="sd">    (`choices`), `a` and each choice array are first broadcast, as necessary,</span>
<span class="sd">    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =</span>
<span class="sd">    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``</span>
<span class="sd">    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as</span>
<span class="sd">    follows:</span>

<span class="sd">    * if ``mode=raise`` (the default), then, first of all, each element of</span>
<span class="sd">      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that</span>
<span class="sd">      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position</span>
<span class="sd">      in `Ba` - then the value at the same position in the new array is the</span>
<span class="sd">      value in `Bchoices[i]` at that same position;</span>

<span class="sd">    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)</span>
<span class="sd">      integer; modular arithmetic is used to map integers outside the range</span>
<span class="sd">      `[0, n-1]` back into that range; and then the new array is constructed</span>
<span class="sd">      as above;</span>

<span class="sd">    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)</span>
<span class="sd">      integer; negative integers are mapped to 0; values greater than `n-1`</span>
<span class="sd">      are mapped to `n-1`; and then the new array is constructed as above.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : int array</span>
<span class="sd">        This array must contain integers in `[0, n-1]`, where `n` is the number</span>
<span class="sd">        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any</span>
<span class="sd">        integers are permissible.</span>
<span class="sd">    choices : sequence of arrays</span>
<span class="sd">        Choice arrays. `a` and all of the choices must be broadcastable to the</span>
<span class="sd">        same shape.  If `choices` is itself an array (not recommended), then</span>
<span class="sd">        its outermost dimension (i.e., the one corresponding to</span>
<span class="sd">        ``choices.shape[0]``) is taken as defining the &quot;sequence&quot;.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>
<span class="sd">    mode : {&#39;raise&#39; (default), &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how indices outside `[0, n-1]` will be treated:</span>

<span class="sd">          * &#39;raise&#39; : an exception is raised</span>
<span class="sd">          * &#39;wrap&#39; : value becomes value mod `n`</span>
<span class="sd">          * &#39;clip&#39; : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    merged_array : array</span>
<span class="sd">        The merged result.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError: shape mismatch</span>
<span class="sd">        If `a` and each choice array are not all broadcastable to the same</span>
<span class="sd">        shape.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.choose : equivalent method</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To reduce the chance of misinterpretation, even though the following</span>
<span class="sd">    &quot;abuse&quot; is nominally supported, `choices` should neither be, nor be</span>
<span class="sd">    thought of as, a single array, i.e., the outermost sequence-like container</span>
<span class="sd">    should be either a list or a tuple.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],</span>
<span class="sd">    ...   [20, 21, 22, 23], [30, 31, 32, 33]]</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 3, 1, 0], choices</span>
<span class="sd">    ... # the first element of the result will be the first element of the</span>
<span class="sd">    ... # third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="sd">    ... # will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="sd">    ... # 31, etc.</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;clip&#39;) # 4 goes to 3 (4-1)</span>
<span class="sd">    array([20, 31, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; # because there are 4 choice arrays</span>
<span class="sd">    &gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode=&#39;wrap&#39;) # 4 goes to (4 mod 4)</span>
<span class="sd">    array([20,  1, 12,  3])</span>
<span class="sd">    &gt;&gt;&gt; # i.e., 0</span>

<span class="sd">    A couple examples illustrating how choose broadcasts:</span>

<span class="sd">    &gt;&gt;&gt; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; choices = [-10, 10]</span>
<span class="sd">    &gt;&gt;&gt; np.choose(a, choices)</span>
<span class="sd">    array([[ 10, -10,  10],</span>
<span class="sd">           [-10,  10, -10],</span>
<span class="sd">           [ 10, -10,  10]])</span>

<span class="sd">    &gt;&gt;&gt; # With thanks to Anne Archibald</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([0, 1]).reshape((2,1,1))</span>
<span class="sd">    &gt;&gt;&gt; c1 = np.array([1, 2, 3]).reshape((1,3,1))</span>
<span class="sd">    &gt;&gt;&gt; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))</span>
<span class="sd">    &gt;&gt;&gt; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2</span>
<span class="sd">    array([[[ 1,  1,  1,  1,  1],</span>
<span class="sd">            [ 2,  2,  2,  2,  2],</span>
<span class="sd">            [ 3,  3,  3,  3,  3]],</span>
<span class="sd">           [[-1, -2, -3, -4, -5],</span>
<span class="sd">            [-1, -2, -3, -4, -5],</span>
<span class="sd">            [-1, -2, -3, -4, -5]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repeat elements of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    repeats : int or array of ints</span>
<span class="sd">        The number of repetitions for each element.  `repeats` is broadcasted</span>
<span class="sd">        to fit the shape of the given axis.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to repeat values.  By default, use the</span>
<span class="sd">        flattened input array, and return a flat output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    repeated_array : ndarray</span>
<span class="sd">        Output array which has the same shape as `a`, except along</span>
<span class="sd">        the given axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    tile : Tile an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(3, 4)</span>
<span class="sd">    array([3, 3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 2)</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 3, axis=1)</span>
<span class="sd">    array([[1, 1, 1, 2, 2, 2],</span>
<span class="sd">           [3, 3, 3, 4, 4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces specified elements of an array with given values.</span>

<span class="sd">    The indexing works on the flattened target array. `put` is roughly</span>
<span class="sd">    equivalent to:</span>

<span class="sd">    ::</span>

<span class="sd">        a.flat[ind] = v</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Target array.</span>
<span class="sd">    ind : array_like</span>
<span class="sd">        Target indices, interpreted as integers.</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Values to place in `a` at target indices. If `v` is shorter than</span>
<span class="sd">        `ind` it will be repeated as necessary.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; -- raise an error (default)</span>
<span class="sd">        * &#39;wrap&#39; -- wrap around</span>
<span class="sd">        * &#39;clip&#39; -- clip to the range</span>

<span class="sd">        &#39;clip&#39; mode means that all indices that are too large are replaced</span>
<span class="sd">        by the index that addresses the last element along that axis. Note</span>
<span class="sd">        that this disables indexing with negative numbers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    putmask, place</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-44,   1, -55,   3,   4])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, 22, -5, mode=&#39;clip&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([ 0,  1,  2,  3, -5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">put</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">put</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument 1 must be numpy.ndarray, &quot;</span>
                        <span class="s2">&quot;not </span><span class="si">{name}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">put</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interchange two axes of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis1 : int</span>
<span class="sd">        First axis.</span>
<span class="sd">    axis2 : int</span>
<span class="sd">        Second axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_swapped : ndarray</span>
<span class="sd">        For NumPy &gt;= 1.10.0, if `a` is an ndarray, then a view of `a` is</span>
<span class="sd">        returned; otherwise a new array is created. For earlier NumPy</span>
<span class="sd">        versions a view of `a` is returned only if the order of the</span>
<span class="sd">        axes is changed, otherwise the input array is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.swapaxes(x,0,1)</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [2],</span>
<span class="sd">           [3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>

<span class="sd">    &gt;&gt;&gt; np.swapaxes(x,0,2)</span>
<span class="sd">    array([[[0, 4],</span>
<span class="sd">            [2, 6]],</span>
<span class="sd">           [[1, 5],</span>
<span class="sd">            [3, 7]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permute the dimensions of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axes : list of ints, optional</span>
<span class="sd">        By default, reverse the dimensions, otherwise permute the axes</span>
<span class="sd">        according to the values given.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        `a` with its axes permuted.  A view is returned whenever</span>
<span class="sd">        possible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    moveaxis</span>
<span class="sd">    argsort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Use `transpose(a, argsort(axes))` to invert the transposition of tensors</span>
<span class="sd">    when using the `axes` keyword argument.</span>

<span class="sd">    Transposing a 1-D array returns an unchanged view of the original array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    &gt;&gt;&gt; np.transpose(x)</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [1, 3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.ones((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape</span>
<span class="sd">    (2, 1, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;transpose&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;introselect&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a partitioned copy of an array.</span>

<span class="sd">    Creates a copy of the array with its elements rearranged in such a</span>
<span class="sd">    way that the value of the element in k-th position is in the</span>
<span class="sd">    position it would be in a sorted array. All elements smaller than</span>
<span class="sd">    the k-th element are moved before this element and all equal or</span>
<span class="sd">    greater are moved behind it. The ordering of the elements in the two</span>
<span class="sd">    partitions is undefined.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>
<span class="sd">    kth : int or sequence of ints</span>
<span class="sd">        Element index to partition by. The k-th value of the element</span>
<span class="sd">        will be in its final sorted position and all smaller elements</span>
<span class="sd">        will be moved before it and all equal or greater elements behind</span>
<span class="sd">        it. The order all elements in the partitions is undefined. If</span>
<span class="sd">        provided with a sequence of k-th it will partition all elements</span>
<span class="sd">        indexed by k-th  of them into their sorted position at once.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">        sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">    kind : {&#39;introselect&#39;}, optional</span>
<span class="sd">        Selection algorithm. Default is &#39;introselect&#39;.</span>
<span class="sd">    order : str or list of str, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument</span>
<span class="sd">        specifies which fields to compare first, second, etc.  A single</span>
<span class="sd">        field can be specified as a string.  Not all fields need be</span>
<span class="sd">        specified, but unspecified fields will still be used, in the</span>
<span class="sd">        order in which they come up in the dtype, to break ties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    partitioned_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.partition : Method to sort an array in-place.</span>
<span class="sd">    argpartition : Indirect partition.</span>
<span class="sd">    sort : Full sorting</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The various selection algorithms are characterized by their average</span>
<span class="sd">    speed, worst case performance, work space size, and whether they are</span>
<span class="sd">    stable. A stable sort keeps items with the same key in the same</span>
<span class="sd">    relative order. The available algorithms have the following</span>
<span class="sd">    properties:</span>

<span class="sd">    ================= ======= ============= ============ =======</span>
<span class="sd">       kind            speed   worst case    work space  stable</span>
<span class="sd">    ================= ======= ============= ============ =======</span>
<span class="sd">    &#39;introselect&#39;        1        O(n)           0         no</span>
<span class="sd">    ================= ======= ============= ============ =======</span>

<span class="sd">    All the partition algorithms make temporary copies of the data when</span>
<span class="sd">    partitioning along any but the last axis.  Consequently,</span>
<span class="sd">    partitioning along the last axis is faster and uses less space than</span>
<span class="sd">    partitioning along any other axis.</span>

<span class="sd">    The sort order for complex numbers is lexicographic. If both the</span>
<span class="sd">    real and imaginary parts are non-nan then the order is determined by</span>
<span class="sd">    the real parts except when they are equal, in which case the order</span>
<span class="sd">    is determined by the imaginary parts.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([3, 4, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.partition(a, 3)</span>
<span class="sd">    array([2, 1, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; np.partition(a, (1, 3))</span>
<span class="sd">    array([1, 2, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;K&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">argpartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;introselect&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an indirect partition along the given axis using the</span>
<span class="sd">    algorithm specified by the `kind` keyword. It returns an array of</span>
<span class="sd">    indices of the same shape as `a` that index data along the given</span>
<span class="sd">    axis in partitioned order.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to sort.</span>
<span class="sd">    kth : int or sequence of ints</span>
<span class="sd">        Element index to partition by. The k-th element will be in its</span>
<span class="sd">        final sorted position and all smaller elements will be moved</span>
<span class="sd">        before it and all larger elements behind it. The order all</span>
<span class="sd">        elements in the partitions is undefined. If provided with a</span>
<span class="sd">        sequence of k-th it will partition all of them into their sorted</span>
<span class="sd">        position at once.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort. The default is -1 (the last axis). If</span>
<span class="sd">        None, the flattened array is used.</span>
<span class="sd">    kind : {&#39;introselect&#39;}, optional</span>
<span class="sd">        Selection algorithm. Default is &#39;introselect&#39;</span>
<span class="sd">    order : str or list of str, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument</span>
<span class="sd">        specifies which fields to compare first, second, etc. A single</span>
<span class="sd">        field can be specified as a string, and not all fields need be</span>
<span class="sd">        specified, but unspecified fields will still be used, in the</span>
<span class="sd">        order in which they come up in the dtype, to break ties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray, int</span>
<span class="sd">        Array of indices that partition `a` along the specified axis.</span>
<span class="sd">        In other words, ``a[index_array]`` yields a partitioned `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    partition : Describes partition algorithms used.</span>
<span class="sd">    ndarray.partition : Inplace partition.</span>
<span class="sd">    argsort : Full indirect sort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See `partition` for notes on the different selection algorithms.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    One dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([3, 4, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; x[np.argpartition(x, 3)]</span>
<span class="sd">    array([2, 1, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; x[np.argpartition(x, (1, 3))]</span>
<span class="sd">    array([1, 2, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; x = [3, 4, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; np.array(x)[np.argpartition(x, 3)]</span>
<span class="sd">    array([2, 1, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;argpartition&#39;</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sorted copy of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">        sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">        Sorting algorithm. Default is &#39;quicksort&#39;.</span>
<span class="sd">    order : str or list of str, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">        which fields to compare first, second, etc.  A single field can</span>
<span class="sd">        be specified as a string, and not all fields need be specified,</span>
<span class="sd">        but unspecified fields will still be used, in the order in which</span>
<span class="sd">        they come up in the dtype, to break ties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sorted_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.sort : Method to sort an array in-place.</span>
<span class="sd">    argsort : Indirect sort.</span>
<span class="sd">    lexsort : Indirect stable sort on multiple keys.</span>
<span class="sd">    searchsorted : Find elements in a sorted array.</span>
<span class="sd">    partition : Partial sort.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The various sorting algorithms are characterized by their average speed,</span>
<span class="sd">    worst case performance, work space size, and whether they are stable. A</span>
<span class="sd">    stable sort keeps items with the same key in the same relative</span>
<span class="sd">    order. The three available algorithms have the following</span>
<span class="sd">    properties:</span>

<span class="sd">    =========== ======= ============= ============ =======</span>
<span class="sd">       kind      speed   worst case    work space  stable</span>
<span class="sd">    =========== ======= ============= ============ =======</span>
<span class="sd">    &#39;quicksort&#39;    1     O(n^2)            0          no</span>
<span class="sd">    &#39;mergesort&#39;    2     O(n*log(n))      ~n/2        yes</span>
<span class="sd">    &#39;heapsort&#39;     3     O(n*log(n))       0          no</span>
<span class="sd">    =========== ======= ============= ============ =======</span>

<span class="sd">    All the sort algorithms make temporary copies of the data when</span>
<span class="sd">    sorting along any but the last axis.  Consequently, sorting along</span>
<span class="sd">    the last axis is faster and uses less space than sorting along</span>
<span class="sd">    any other axis.</span>

<span class="sd">    The sort order for complex numbers is lexicographic. If both the real</span>
<span class="sd">    and imaginary parts are non-nan then the order is determined by the</span>
<span class="sd">    real parts except when they are equal, in which case the order is</span>
<span class="sd">    determined by the imaginary parts.</span>

<span class="sd">    Previous to numpy 1.4.0 sorting real and complex arrays containing nan</span>
<span class="sd">    values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan</span>
<span class="sd">    values are sorted to the end. The extended sort order is:</span>

<span class="sd">      * Real: [R, nan]</span>
<span class="sd">      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</span>

<span class="sd">    where R is a non-nan real value. Complex values with the same nan</span>
<span class="sd">    placements are sorted according to the non-nan part if it exists.</span>
<span class="sd">    Non-nan values are sorted as before.</span>

<span class="sd">    .. versionadded:: 1.12.0</span>

<span class="sd">    quicksort has been changed to an introsort which will switch</span>
<span class="sd">    heapsort when it does not make enough progress. This makes its</span>
<span class="sd">    worst case O(n*log(n)).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,4],[3,1]])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a)                # sort along the last axis</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array</span>
<span class="sd">    array([1, 1, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    Use the `order` keyword to specify a field to use when sorting a</span>
<span class="sd">    structured array:</span>

<span class="sd">    &gt;&gt;&gt; dtype = [(&#39;name&#39;, &#39;S10&#39;), (&#39;height&#39;, float), (&#39;age&#39;, int)]</span>
<span class="sd">    &gt;&gt;&gt; values = [(&#39;Arthur&#39;, 1.8, 41), (&#39;Lancelot&#39;, 1.9, 38),</span>
<span class="sd">    ...           (&#39;Galahad&#39;, 1.7, 38)]</span>
<span class="sd">    &gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array</span>
<span class="sd">    &gt;&gt;&gt; np.sort(a, order=&#39;height&#39;)                        # doctest: +SKIP</span>
<span class="sd">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="sd">           (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="sd">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    Sort by age, then height if ages are equal:</span>

<span class="sd">    &gt;&gt;&gt; np.sort(a, order=[&#39;age&#39;, &#39;height&#39;])               # doctest: +SKIP</span>
<span class="sd">    array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="sd">           (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="sd">          dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;K&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices that would sort an array.</span>

<span class="sd">    Perform an indirect sort along the given axis using the algorithm specified</span>
<span class="sd">    by the `kind` keyword. It returns an array of indices of the same shape as</span>
<span class="sd">    `a` that index data along the given axis in sorted order.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to sort.</span>
<span class="sd">    axis : int or None, optional</span>
<span class="sd">        Axis along which to sort.  The default is -1 (the last axis). If None,</span>
<span class="sd">        the flattened array is used.</span>
<span class="sd">    kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">        Sorting algorithm.</span>
<span class="sd">    order : str or list of str, optional</span>
<span class="sd">        When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">        which fields to compare first, second, etc.  A single field can</span>
<span class="sd">        be specified as a string, and not all fields need be specified,</span>
<span class="sd">        but unspecified fields will still be used, in the order in which</span>
<span class="sd">        they come up in the dtype, to break ties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray, int</span>
<span class="sd">        Array of indices that sort `a` along the specified axis.</span>
<span class="sd">        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort : Describes sorting algorithms used.</span>
<span class="sd">    lexsort : Indirect stable sort with multiple keys.</span>
<span class="sd">    ndarray.sort : Inplace sort.</span>
<span class="sd">    argpartition : Indirect partial sort.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See `sort` for notes on the different sorting algorithms.</span>

<span class="sd">    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing</span>
<span class="sd">    nan values. The enhanced sort order is documented in `sort`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    One dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([3, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.argsort(x)</span>
<span class="sd">    array([1, 2, 0])</span>

<span class="sd">    Two-dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 3],</span>
<span class="sd">           [2, 2]])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, axis=0)  # sorts along first axis (down)</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [1, 0]])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, axis=1)  # sorts along last axis (across)</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [0, 1]])</span>

<span class="sd">    Indices of the sorted elements of a N-dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)</span>
<span class="sd">    &gt;&gt;&gt; ind</span>
<span class="sd">    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; x[ind]  # same as np.sort(x, axis=None)</span>
<span class="sd">    array([0, 2, 2, 3])</span>

<span class="sd">    Sorting with keys:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([(1, 0), (0, 1)],</span>
<span class="sd">          dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, order=(&#39;x&#39;,&#39;y&#39;))</span>
<span class="sd">    array([1, 0])</span>

<span class="sd">    &gt;&gt;&gt; np.argsort(x, order=(&#39;y&#39;,&#39;x&#39;))</span>
<span class="sd">    array([0, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;argsort&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices of the maximum values along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        By default, the index is into the flattened array, otherwise</span>
<span class="sd">        along the specified axis.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray of ints</span>
<span class="sd">        Array of indices into the array. It has the same shape as `a.shape`</span>
<span class="sd">        with the dimension along `axis` removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.argmax, argmin</span>
<span class="sd">    amax : The maximum value along a given axis.</span>
<span class="sd">    unravel_index : Convert a flat index into an index tuple.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In case of multiple occurrences of the maximum values, the indices</span>
<span class="sd">    corresponding to the first occurrence are returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a, axis=0)</span>
<span class="sd">    array([1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a, axis=1)</span>
<span class="sd">    array([2, 2])</span>

<span class="sd">    Indexes of the maximal elements of a N-dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)</span>
<span class="sd">    &gt;&gt;&gt; ind</span>
<span class="sd">    (1, 2)</span>
<span class="sd">    &gt;&gt;&gt; a[ind]</span>
<span class="sd">    5</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; b[1] = 5</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([0, 5, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(b)  # Only the first occurrence is returned.</span>
<span class="sd">    1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;argmax&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices of the minimum values along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        By default, the index is into the flattened array, otherwise</span>
<span class="sd">        along the specified axis.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray of ints</span>
<span class="sd">        Array of indices into the array. It has the same shape as `a.shape`</span>
<span class="sd">        with the dimension along `axis` removed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.argmin, argmax</span>
<span class="sd">    amin : The minimum value along a given axis.</span>
<span class="sd">    unravel_index : Convert a flat index into an index tuple.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In case of multiple occurrences of the minimum values, the indices</span>
<span class="sd">    corresponding to the first occurrence are returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.argmin(a)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; np.argmin(a, axis=0)</span>
<span class="sd">    array([0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.argmin(a, axis=1)</span>
<span class="sd">    array([0, 0])</span>

<span class="sd">    Indices of the minimum elements of a N-dimensional array:</span>

<span class="sd">    &gt;&gt;&gt; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)</span>
<span class="sd">    &gt;&gt;&gt; ind</span>
<span class="sd">    (0, 0)</span>
<span class="sd">    &gt;&gt;&gt; a[ind]</span>
<span class="sd">    0</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; b[4] = 0</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([0, 1, 2, 3, 0, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.argmin(b)  # Only the first occurrence is returned.</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find indices where elements should be inserted to maintain order.</span>

<span class="sd">    Find the indices into a sorted array `a` such that, if the</span>
<span class="sd">    corresponding elements in `v` were inserted before the indices, the</span>
<span class="sd">    order of `a` would be preserved.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : 1-D array_like</span>
<span class="sd">        Input array. If `sorter` is None, then it must be sorted in</span>
<span class="sd">        ascending order, otherwise `sorter` must be an array of indices</span>
<span class="sd">        that sort it.</span>
<span class="sd">    v : array_like</span>
<span class="sd">        Values to insert into `a`.</span>
<span class="sd">    side : {&#39;left&#39;, &#39;right&#39;}, optional</span>
<span class="sd">        If &#39;left&#39;, the index of the first suitable location found is given.</span>
<span class="sd">        If &#39;right&#39;, return the last such index.  If there is no suitable</span>
<span class="sd">        index, return either 0 or N (where N is the length of `a`).</span>
<span class="sd">    sorter : 1-D array_like, optional</span>
<span class="sd">        Optional array of integer indices that sort array a into ascending</span>
<span class="sd">        order. They are typically the result of argsort.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : array of ints</span>
<span class="sd">        Array of insertion points with the same shape as `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort : Return a sorted copy of an array.</span>
<span class="sd">    histogram : Produce histogram from 1-D data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Binary search is used to find the required insertion points.</span>

<span class="sd">    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing</span>
<span class="sd">    `nan` values. The enhanced sort order is documented in `sort`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side=&#39;right&#39;)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])</span>
<span class="sd">    array([0, 5, 1, 2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;searchsorted&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with the specified shape.</span>

<span class="sd">    If the new array is larger than the original array, then the new</span>
<span class="sd">    array is filled with repeated copies of `a`.  Note that this behavior</span>
<span class="sd">    is different from a.resize(new_shape) which fills with zeros instead</span>
<span class="sd">    of repeated copies of `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be resized.</span>

<span class="sd">    new_shape : int or tuple of int</span>
<span class="sd">        Shape of resized array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reshaped_array : ndarray</span>
<span class="sd">        The new array is formed from the data in the old array, repeated</span>
<span class="sd">        if necessary to fill out the required number of elements.  The</span>
<span class="sd">        data are repeated in the order that they are stored in memory.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.resize : resize an array in-place.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a=np.array([[0,1],[2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a,(2,3))</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a,(1,4))</span>
<span class="sd">    array([[0, 1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a,(2,4))</span>
<span class="sd">    array([[0, 1, 2, 3],</span>
<span class="sd">           [0, 1, 2, 3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">nt</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_shape</span><span class="p">,)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">total_size</span> <span class="o">=</span> <span class="n">um</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Na</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">total_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mu</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">n_copies</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_size</span> <span class="o">/</span> <span class="n">Na</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">%</span> <span class="n">Na</span>

    <span class="k">if</span> <span class="n">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_copies</span> <span class="o">=</span> <span class="n">n_copies</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">Na</span> <span class="o">-</span> <span class="n">extra</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,)</span><span class="o">*</span><span class="n">n_copies</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extra</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="n">extra</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove single-dimensional entries from the shape of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        Selects a subset of the single-dimensional entries in the</span>
<span class="sd">        shape. If an axis is selected with shape entry greater than</span>
<span class="sd">        one, an error is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    squeezed : ndarray</span>
<span class="sd">        The input array, but with all or a subset of the</span>
<span class="sd">        dimensions of length 1 removed. This is always `a` itself</span>
<span class="sd">        or a view into `a`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `axis` is not `None`, and an axis being squeezed is not of length 1</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    expand_dims : The inverse operation, adding singleton dimensions</span>
<span class="sd">    reshape : Insert, remove, and combine dimensions, and resize existing ones</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[[0], [1], [2]]])</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (1, 3, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x).shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=0).shape</span>
<span class="sd">    (3, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=1).shape</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: cannot select an axis to squeeze out which has size not equal to one</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=2).shape</span>
<span class="sd">    (1, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">squeeze</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">squeeze</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_wrapit</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;squeeze&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># First try to use the new axis= parameter</span>
        <span class="k">return</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="k">return</span> <span class="n">squeeze</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return specified diagonals.</span>

<span class="sd">    If `a` is 2-D, returns the diagonal of `a` with the given offset,</span>
<span class="sd">    i.e., the collection of elements of the form ``a[i, i+offset]``.  If</span>
<span class="sd">    `a` has more than two dimensions, then the axes specified by `axis1`</span>
<span class="sd">    and `axis2` are used to determine the 2-D sub-array whose diagonal is</span>
<span class="sd">    returned.  The shape of the resulting array can be determined by</span>
<span class="sd">    removing `axis1` and `axis2` and appending an index to the right equal</span>
<span class="sd">    to the size of the resulting diagonals.</span>

<span class="sd">    In versions of NumPy prior to 1.7, this function always returned a new,</span>
<span class="sd">    independent array containing a copy of the values in the diagonal.</span>

<span class="sd">    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,</span>
<span class="sd">    but depending on this fact is deprecated. Writing to the resulting</span>
<span class="sd">    array continues to work as it used to, but a FutureWarning is issued.</span>

<span class="sd">    Starting in NumPy 1.9 it returns a read-only view on the original array.</span>
<span class="sd">    Attempting to write to the resulting array will produce an error.</span>

<span class="sd">    In some future release, it will return a read/write view and writing to</span>
<span class="sd">    the returned array will alter your original array.  The returned array</span>
<span class="sd">    will have the same type as the input array.</span>

<span class="sd">    If you don&#39;t write to the array returned by this function, then you can</span>
<span class="sd">    just ignore all of the above.</span>

<span class="sd">    If you depend on the current behavior, then we suggest copying the</span>
<span class="sd">    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead</span>
<span class="sd">    of just ``np.diagonal(a)``. This will work with both past and future</span>
<span class="sd">    versions of NumPy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array from which the diagonals are taken.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset of the diagonal from the main diagonal.  Can be positive or</span>
<span class="sd">        negative.  Defaults to main diagonal (0).</span>
<span class="sd">    axis1 : int, optional</span>
<span class="sd">        Axis to be used as the first axis of the 2-D sub-arrays from which</span>
<span class="sd">        the diagonals should be taken.  Defaults to first axis (0).</span>
<span class="sd">    axis2 : int, optional</span>
<span class="sd">        Axis to be used as the second axis of the 2-D sub-arrays from</span>
<span class="sd">        which the diagonals should be taken. Defaults to second axis (1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_of_diagonals : ndarray</span>
<span class="sd">        If `a` is 2-D and not a `matrix`, a 1-D array of the same type as `a`</span>
<span class="sd">        containing the diagonal is returned. If `a` is a `matrix`, a 1-D</span>
<span class="sd">        array containing the diagonal is returned in order to maintain</span>
<span class="sd">        backward compatibility.</span>
<span class="sd">        If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`</span>
<span class="sd">        are removed, and a new axis inserted at the end corresponding to the</span>
<span class="sd">        diagonal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dimension of `a` is less than 2.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    diag : MATLAB work-a-like for 1-D and 2-D arrays.</span>
<span class="sd">    diagflat : Create diagonal arrays.</span>
<span class="sd">    trace : Sum along diagonals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape(2,2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal()</span>
<span class="sd">    array([0, 3])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(1)</span>
<span class="sd">    array([1])</span>

<span class="sd">    A 3-D example:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape(2,2,2); a</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(0, # Main diagonals of two arrays created by skipping</span>
<span class="sd">    ...            0, # across the outer(left)-most axis last and</span>
<span class="sd">    ...            1) # the &quot;middle&quot; (row) axis first.</span>
<span class="sd">    array([[0, 6],</span>
<span class="sd">           [1, 7]])</span>

<span class="sd">    The sub-arrays whose main diagonals we just obtained; note that each</span>
<span class="sd">    corresponds to fixing the right-most (column) axis, and that the</span>
<span class="sd">    diagonals are &quot;packed&quot; in rows.</span>

<span class="sd">    &gt;&gt;&gt; a[:,:,0] # main diagonal is [0 6]</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [4, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a[:,:,1] # main diagonal is [1 7]</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [5, 7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="c1"># Make diagonal of matrix 1-D to preserve backward compatibility.</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum along diagonals of the array.</span>

<span class="sd">    If `a` is 2-D, the sum along its diagonal with the given offset</span>
<span class="sd">    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.</span>

<span class="sd">    If `a` has more than two dimensions, then the axes specified by axis1 and</span>
<span class="sd">    axis2 are used to determine the 2-D sub-arrays whose traces are returned.</span>
<span class="sd">    The shape of the resulting array is the same as that of `a` with `axis1`</span>
<span class="sd">    and `axis2` removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array, from which the diagonals are taken.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be both positive</span>
<span class="sd">        and negative. Defaults to 0.</span>
<span class="sd">    axis1, axis2 : int, optional</span>
<span class="sd">        Axes to be used as the first and second axis of the 2-D sub-arrays</span>
<span class="sd">        from which the diagonals should be taken. Defaults are the first two</span>
<span class="sd">        axes of `a`.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Determines the data-type of the returned array and of the accumulator</span>
<span class="sd">        where the elements are summed. If dtype has the value None and `a` is</span>
<span class="sd">        of integer type of precision less than the default integer</span>
<span class="sd">        precision, then the default integer precision is used. Otherwise,</span>
<span class="sd">        the precision is the same as that of `a`.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Array into which the output is placed. Its type is preserved and</span>
<span class="sd">        it must be of the right shape to hold the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_along_diagonals : ndarray</span>
<span class="sd">        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has</span>
<span class="sd">        larger dimensions, then an array of sums along diagonals is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    diag, diagonal, diagflat</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.trace(np.eye(3))</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; np.trace(a)</span>
<span class="sd">    array([6, 8])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))</span>
<span class="sd">    &gt;&gt;&gt; np.trace(a).shape</span>
<span class="sd">    (2, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="c1"># Get trace of matrix via an array to preserve backward compatibility.</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a contiguous flattened array.</span>

<span class="sd">    A 1-D array, containing the elements of the input, is returned.  A copy is</span>
<span class="sd">    made only if needed.</span>

<span class="sd">    As of NumPy 1.10, the returned array will have the same type as the input</span>
<span class="sd">    array. (for example, a masked array will be returned for a masked array</span>
<span class="sd">    input)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.  The elements in `a` are read in the order specified by</span>
<span class="sd">        `order`, and packed as a 1-D array.</span>
<span class="sd">    order : {&#39;C&#39;,&#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>

<span class="sd">        The elements of `a` are read using this index order. &#39;C&#39; means</span>
<span class="sd">        to index the elements in row-major, C-style order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first</span>
<span class="sd">        axis index changing slowest.  &#39;F&#39; means to index the elements</span>
<span class="sd">        in column-major, Fortran-style order, with the</span>
<span class="sd">        first index changing fastest, and the last index changing</span>
<span class="sd">        slowest. Note that the &#39;C&#39; and &#39;F&#39; options take no account of</span>
<span class="sd">        the memory layout of the underlying array, and only refer to</span>
<span class="sd">        the order of axis indexing.  &#39;A&#39; means to read the elements in</span>
<span class="sd">        Fortran-like index order if `a` is Fortran *contiguous* in</span>
<span class="sd">        memory, C-like order otherwise.  &#39;K&#39; means to read the</span>
<span class="sd">        elements in the order they occur in memory, except for</span>
<span class="sd">        reversing the data when strides are negative.  By default, &#39;C&#39;</span>
<span class="sd">        index order is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        If `a` is a matrix, y is a 1-D ndarray, otherwise y is an array of</span>
<span class="sd">        the same subtype as `a`. The shape of the returned array is</span>
<span class="sd">        ``(a.size,)``. Matrices are special cased for backward</span>
<span class="sd">        compatibility.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.flat : 1-D iterator over an array.</span>
<span class="sd">    ndarray.flatten : 1-D array copy of the elements of an array</span>
<span class="sd">                      in row-major order.</span>
<span class="sd">    ndarray.reshape : Change the shape of an array without changing its data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In row-major, C-style order, in two dimensions, the row index</span>
<span class="sd">    varies the slowest, and the column index the quickest.  This can</span>
<span class="sd">    be generalized to multiple dimensions, where row-major order</span>
<span class="sd">    implies that the index along the first axis varies slowest, and</span>
<span class="sd">    the index along the last quickest.  The opposite holds for</span>
<span class="sd">    column-major, Fortran-style index ordering.</span>

<span class="sd">    When a view is desired in as many cases as possible, ``arr.reshape(-1)``</span>
<span class="sd">    may be preferable.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    It is equivalent to ``reshape(-1, order=order)``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; print(np.ravel(x))</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    &gt;&gt;&gt; print(x.reshape(-1))</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    &gt;&gt;&gt; print(np.ravel(x, order=&#39;F&#39;))</span>
<span class="sd">    [1 4 2 5 3 6]</span>

<span class="sd">    When ``order`` is &#39;A&#39;, it will preserve the array&#39;s &#39;C&#39; or &#39;F&#39; ordering:</span>

<span class="sd">    &gt;&gt;&gt; print(np.ravel(x.T))</span>
<span class="sd">    [1 4 2 5 3 6]</span>
<span class="sd">    &gt;&gt;&gt; print(np.ravel(x.T, order=&#39;A&#39;))</span>
<span class="sd">    [1 2 3 4 5 6]</span>

<span class="sd">    When ``order`` is &#39;K&#39;, it will preserve orderings that are neither &#39;C&#39;</span>
<span class="sd">    nor &#39;F&#39;, but won&#39;t reverse axes:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(3)[::-1]; a</span>
<span class="sd">    array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span>
<span class="sd">    array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span>
<span class="sd">    array([2, 1, 0])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a</span>
<span class="sd">    array([[[ 0,  2,  4],</span>
<span class="sd">            [ 1,  3,  5]],</span>
<span class="sd">           [[ 6,  8, 10],</span>
<span class="sd">            [ 7,  9, 11]]])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;C&#39;)</span>
<span class="sd">    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="sd">    &gt;&gt;&gt; a.ravel(order=&#39;K&#39;)</span>
<span class="sd">    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the elements that are non-zero.</span>

<span class="sd">    Returns a tuple of arrays, one for each dimension of `a`,</span>
<span class="sd">    containing the indices of the non-zero elements in that</span>
<span class="sd">    dimension. The values in `a` are always tested and returned in</span>
<span class="sd">    row-major, C-style order. The corresponding non-zero</span>
<span class="sd">    values can be obtained with::</span>

<span class="sd">        a[nonzero(a)]</span>

<span class="sd">    To group the indices by element, rather than dimension, use::</span>

<span class="sd">        transpose(nonzero(a))</span>

<span class="sd">    The result of this is always a 2-D array, with a row for</span>
<span class="sd">    each non-zero element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple_of_arrays : tuple</span>
<span class="sd">        Indices of elements that are non-zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnonzero :</span>
<span class="sd">        Return indices that are non-zero in the flattened version of the input</span>
<span class="sd">        array.</span>
<span class="sd">    ndarray.nonzero :</span>
<span class="sd">        Equivalent ndarray method.</span>
<span class="sd">    count_nonzero :</span>
<span class="sd">        Counts the number of non-zero elements in the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,0,0], [0,2,0], [1,1,0]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[1, 0, 0],</span>
<span class="sd">           [0, 2, 0],</span>
<span class="sd">           [1, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(x)</span>
<span class="sd">    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>

<span class="sd">    &gt;&gt;&gt; x[np.nonzero(x)]</span>
<span class="sd">    array([1, 2, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(np.nonzero(x))</span>
<span class="sd">    array([[0, 0],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [2, 0],</span>
<span class="sd">           [2, 1])</span>

<span class="sd">    A common use for ``nonzero`` is to find the indices of an array, where</span>
<span class="sd">    a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a</span>
<span class="sd">    boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)</span>
<span class="sd">    yields the indices of the `a` where the condition is true.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6],[7,8,9]])</span>
<span class="sd">    &gt;&gt;&gt; a &gt; 3</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True]])</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(a &gt; 3)</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    The ``nonzero`` method of the boolean array can also be called.</span>

<span class="sd">    &gt;&gt;&gt; (a &gt; 3).nonzero()</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;nonzero&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the shape of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shape : tuple of ints</span>
<span class="sd">        The elements of the shape tuple give the lengths of the</span>
<span class="sd">        corresponding array dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    alen</span>
<span class="sd">    ndarray.shape : Equivalent array method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.shape(np.eye(3))</span>
<span class="sd">    (3, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([[1, 2]])</span>
<span class="sd">    (1, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([0])</span>
<span class="sd">    (1,)</span>
<span class="sd">    &gt;&gt;&gt; np.shape(0)</span>
<span class="sd">    ()</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[(&#39;x&#39;, &#39;i4&#39;), (&#39;y&#39;, &#39;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; np.shape(a)</span>
<span class="sd">    (2,)</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (2,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return selected slices of an array along given axis.</span>

<span class="sd">    When working along a given axis, a slice along that axis is returned in</span>
<span class="sd">    `output` for each index where `condition` evaluates to True. When</span>
<span class="sd">    working on a 1-D array, `compress` is equivalent to `extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : 1-D array of bools</span>
<span class="sd">        Array that selects which entries to return. If len(condition)</span>
<span class="sd">        is less than the size of `a` along the given axis, then output is</span>
<span class="sd">        truncated to the length of the condition array.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array from which to extract a part.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to take slices. If None (default), work on the</span>
<span class="sd">        flattened array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Output array.  Its type is preserved and it must be of the right</span>
<span class="sd">        shape to hold the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    compressed_array : ndarray</span>
<span class="sd">        A copy of `a` without the slices along axis for which `condition`</span>
<span class="sd">        is false.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    take, choose, diag, diagonal, select</span>
<span class="sd">    ndarray.compress : Equivalent method in ndarray</span>
<span class="sd">    np.extract: Equivalent method when working on 1-D arrays</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([0, 1], a, axis=0)</span>
<span class="sd">    array([[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True, True], a, axis=0)</span>
<span class="sd">    array([[3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a, axis=1)</span>
<span class="sd">    array([[2],</span>
<span class="sd">           [4],</span>
<span class="sd">           [6]])</span>

<span class="sd">    Working on the flattened array does not return slices along an axis but</span>
<span class="sd">    selects elements.</span>

<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a)</span>
<span class="sd">    array([2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clip (limit) the values in an array.</span>

<span class="sd">    Given an interval, values outside the interval are clipped to</span>
<span class="sd">    the interval edges.  For example, if an interval of ``[0, 1]``</span>
<span class="sd">    is specified, values smaller than 0 become 0, and values larger</span>
<span class="sd">    than 1 become 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing elements to clip.</span>
<span class="sd">    a_min : scalar or array_like or `None`</span>
<span class="sd">        Minimum value. If `None`, clipping is not performed on lower</span>
<span class="sd">        interval edge. Not more than one of `a_min` and `a_max` may be</span>
<span class="sd">        `None`.</span>
<span class="sd">    a_max : scalar or array_like or `None`</span>
<span class="sd">        Maximum value. If `None`, clipping is not performed on upper</span>
<span class="sd">        interval edge. Not more than one of `a_min` and `a_max` may be</span>
<span class="sd">        `None`. If `a_min` or `a_max` are array_like, then the three</span>
<span class="sd">        arrays will be broadcasted to match their shapes.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        The results will be placed in this array. It may be the input</span>
<span class="sd">        array for in-place clipping.  `out` must be of the right shape</span>
<span class="sd">        to hold the output.  Its type is preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    clipped_array : ndarray</span>
<span class="sd">        An array with the elements of `a`, but where values</span>
<span class="sd">        &lt; `a_min` are replaced with `a_min`, and those &gt; `a_max`</span>
<span class="sd">        with `a_max`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, 1, 8)</span>
<span class="sd">    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, 3, 6, out=a)</span>
<span class="sd">    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)</span>
<span class="sd">    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum of array elements over a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Elements to sum.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a sum is performed.  The default,</span>
<span class="sd">        axis=None, will sum all of the elements of the input array.  If</span>
<span class="sd">        axis is negative it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If axis is a tuple of ints, a sum is performed on all of the axes</span>
<span class="sd">        specified in the tuple instead of a single axis or all the axes as</span>
<span class="sd">        before.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        The type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  The dtype of `a` is used by default unless `a`</span>
<span class="sd">        has an integer dtype of less precision than the default platform</span>
<span class="sd">        integer.  In that case, if `a` is signed then the platform integer</span>
<span class="sd">        is used while if `a` is unsigned then an unsigned integer of the</span>
<span class="sd">        same precision as the platform integer is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output, but the type of the output</span>
<span class="sd">        values will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `sum` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_along_axis : ndarray</span>
<span class="sd">        An array with the same shape as `a`, with the specified</span>
<span class="sd">        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar</span>
<span class="sd">        is returned.  If an output array is specified, a reference to</span>
<span class="sd">        `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.sum : Equivalent method.</span>

<span class="sd">    cumsum : Cumulative sum of array elements.</span>

<span class="sd">    trapz : Integration of array values using the composite trapezoidal rule.</span>

<span class="sd">    mean, average</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    The sum of an empty array is the neutral element 0:</span>

<span class="sd">    &gt;&gt;&gt; np.sum([])</span>
<span class="sd">    0.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.sum([0.5, 1.5])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]])</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)</span>
<span class="sd">    array([0, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)</span>
<span class="sd">    array([1, 5])</span>

<span class="sd">    If the accumulator is too small, overflow occurs:</span>

<span class="sd">    &gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)</span>
<span class="sd">    -128</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_gentype</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_sum_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                         <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product of array elements over a given axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    prod : equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">return</span> <span class="n">um</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sometrue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether some values are true.</span>

<span class="sd">    Refer to `any` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    any : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">alltrue</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if all elements of input array are true.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.all : Equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether any array element along a given axis evaluates to True.</span>

<span class="sd">    Returns single boolean unless `axis` is not ``None``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a logical OR reduction is performed.</span>
<span class="sd">        The default (`axis` = `None`) is to perform a logical OR over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a reduction is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output and its type is preserved</span>
<span class="sd">        (e.g., if it is of type float, then it will remain so, returning</span>
<span class="sd">        1.0 for True and 0.0 for False, regardless of the type of `a`).</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for details.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `any` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    any : bool or ndarray</span>
<span class="sd">        A new boolean or `ndarray` is returned unless `out` is specified,</span>
<span class="sd">        in which case a reference to `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.any : equivalent method</span>

<span class="sd">    all : Test whether all elements along a given axis evaluate to True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not a Number (NaN), positive infinity and negative infinity evaluate</span>
<span class="sd">    to `True` because these are not equal to zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.any([[True, False], [True, True]])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)</span>
<span class="sd">    array([ True, False])</span>

<span class="sd">    &gt;&gt;&gt; np.any([-1, 0, 5])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.any(np.nan)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; o=np.array([False])</span>
<span class="sd">    &gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)</span>
<span class="sd">    &gt;&gt;&gt; z, o</span>
<span class="sd">    (array([ True]), array([ True]))</span>
<span class="sd">    &gt;&gt;&gt; # Check now that z is a reference to o</span>
<span class="sd">    &gt;&gt;&gt; z is o</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; id(z), id(o) # identity of z and o              # doctest: +SKIP</span>
<span class="sd">    (191614240, 191614240)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether all array elements along a given axis evaluate to True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a logical AND reduction is performed.</span>
<span class="sd">        The default (`axis` = `None`) is to perform a logical AND over all</span>
<span class="sd">        the dimensions of the input array. `axis` may be negative, in</span>
<span class="sd">        which case it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a reduction is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.</span>
<span class="sd">        It must have the same shape as the expected output and its</span>
<span class="sd">        type is preserved (e.g., if ``dtype(out)`` is float, the result</span>
<span class="sd">        will consist of 0.0&#39;s and 1.0&#39;s).  See `doc.ufuncs` (Section</span>
<span class="sd">        &quot;Output arguments&quot;) for more details.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `all` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all : ndarray, bool</span>
<span class="sd">        A new boolean or array is returned unless `out` is specified,</span>
<span class="sd">        in which case a reference to `out` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.all : equivalent method</span>

<span class="sd">    any : Test whether any element along a given axis evaluates to True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not a Number (NaN), positive infinity and negative infinity</span>
<span class="sd">    evaluate to `True` because these are not equal to zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.all([[True,False],[True,True]])</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)</span>
<span class="sd">    array([ True, False])</span>

<span class="sd">    &gt;&gt;&gt; np.all([-1, 4, 5])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; np.all([1.0, np.nan])</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; o=np.array([False])</span>
<span class="sd">    &gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)</span>
<span class="sd">    &gt;&gt;&gt; id(z), id(o), z                             # doctest: +SKIP</span>
<span class="sd">    (28293632, 28293632, array([ True]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative sum of the elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the cumulative sum is computed. The default</span>
<span class="sd">        (None) is to compute the cumsum over the flattened array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  If `dtype` is not specified, it defaults</span>
<span class="sd">        to the dtype of `a`, unless `a` has an integer dtype with a</span>
<span class="sd">        precision less than that of the default platform integer.  In</span>
<span class="sd">        that case, the default platform integer is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output</span>
<span class="sd">        but the type will be cast if necessary. See `doc.ufuncs`</span>
<span class="sd">        (Section &quot;Output arguments&quot;) for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cumsum_along_axis : ndarray.</span>
<span class="sd">        A new array holding the result is returned unless `out` is</span>
<span class="sd">        specified, in which case a reference to `out` is returned. The</span>
<span class="sd">        result has the same size as `a`, and the same shape as `a` if</span>
<span class="sd">        `axis` is not None or `a` is a 1-d array.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sum : Sum array elements.</span>

<span class="sd">    trapz : Integration of array values using the composite trapezoidal rule.</span>

<span class="sd">    diff :  Calculate the n-th discrete difference along given axis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a)</span>
<span class="sd">    array([ 1,  3,  6, 10, 15, 21])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)</span>
<span class="sd">    array([  1.,   3.,   6.,  10.,  15.,  21.])</span>

<span class="sd">    &gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [5, 7, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows</span>
<span class="sd">    array([[ 1,  3,  6],</span>
<span class="sd">           [ 4,  9, 15]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;cumsum&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cumproduct</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative product over the given axis.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cumprod : equivalent function; see for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Range of values (maximum - minimum) along an axis.</span>

<span class="sd">    The name of the function comes from the acronym for &#39;peak to peak&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input values.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to find the peaks.  By default, flatten the</span>
<span class="sd">        array.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type of the output values will be cast if necessary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ptp : ndarray</span>
<span class="sd">        A new array holding the result, unless `out` was</span>
<span class="sd">        specified, in which case a reference to `out` is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    &gt;&gt;&gt; np.ptp(x, axis=0)</span>
<span class="sd">    array([2, 2])</span>

<span class="sd">    &gt;&gt;&gt; np.ptp(x, axis=1)</span>
<span class="sd">    array([1, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ptp&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the maximum of an array or maximum along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which to operate.  By default, flattened input is</span>
<span class="sd">        used.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, the maximum is selected over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result.  Must</span>
<span class="sd">        be of the same shape and buffer length as the expected output.</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for more details.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `amax` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amax : ndarray or scalar</span>
<span class="sd">        Maximum of `a`. If `axis` is None, the result is a scalar value.</span>
<span class="sd">        If `axis` is given, the result is an array of dimension</span>
<span class="sd">        ``a.ndim - 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagating any NaNs.</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignoring any NaNs.</span>
<span class="sd">    argmax :</span>
<span class="sd">        Return the indices of the maximum values.</span>

<span class="sd">    nanmin, minimum, fmin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NaN values are propagated, that is if at least one item is NaN, the</span>
<span class="sd">    corresponding max value will be NaN as well. To ignore NaN values</span>
<span class="sd">    (MATLAB behavior), please use nanmax.</span>

<span class="sd">    Don&#39;t use `amax` for element-wise comparison of 2 arrays; when</span>
<span class="sd">    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than</span>
<span class="sd">    ``amax(a, axis=0)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis</span>
<span class="sd">    array([2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis</span>
<span class="sd">    array([1, 3])</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(5, dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; b[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; np.amax(b)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax(b)</span>
<span class="sd">    4.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amax</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">amax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                          <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum of an array or minimum along an axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which to operate.  By default, flattened input is</span>
<span class="sd">        used.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, the minimum is selected over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result.  Must</span>
<span class="sd">        be of the same shape and buffer length as the expected output.</span>
<span class="sd">        See `doc.ufuncs` (Section &quot;Output arguments&quot;) for more details.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `amin` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amin : ndarray or scalar</span>
<span class="sd">        Minimum of `a`. If `axis` is None, the result is a scalar value.</span>
<span class="sd">        If `axis` is given, the result is an array of dimension</span>
<span class="sd">        ``a.ndim - 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagating any NaNs.</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignoring any NaNs.</span>
<span class="sd">    argmin :</span>
<span class="sd">        Return the indices of the minimum values.</span>

<span class="sd">    nanmax, maximum, fmax</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NaN values are propagated, that is if at least one item is NaN, the</span>
<span class="sd">    corresponding min value will be NaN as well. To ignore NaN values</span>
<span class="sd">    (MATLAB behavior), please use nanmin.</span>

<span class="sd">    Don&#39;t use `amin` for element-wise comparison of 2 arrays; when</span>
<span class="sd">    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than</span>
<span class="sd">    ``amin(a, axis=0)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis</span>
<span class="sd">    array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis</span>
<span class="sd">    array([0, 2])</span>

<span class="sd">    &gt;&gt;&gt; b = np.arange(5, dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; b[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; np.amin(b)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin(b)</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amin</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">amin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                          <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">alen</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the length of the first dimension of the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">       Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    alen : int</span>
<span class="sd">       Length of the first dimension of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    shape, size</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,4,5))</span>
<span class="sd">    &gt;&gt;&gt; a.shape[0]</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; np.alen(a)</span>
<span class="sd">    7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product of array elements over a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a product is performed.  The default,</span>
<span class="sd">        axis=None, will calculate the product of all the elements in the</span>
<span class="sd">        input array. If axis is negative it counts from the last to the</span>
<span class="sd">        first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If axis is a tuple of ints, a product is performed on all of the</span>
<span class="sd">        axes specified in the tuple instead of a single axis or all the</span>
<span class="sd">        axes as before.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        The type of the returned array, as well as of the accumulator in</span>
<span class="sd">        which the elements are multiplied.  The dtype of `a` is used by</span>
<span class="sd">        default unless `a` has an integer dtype of less precision than the</span>
<span class="sd">        default platform integer.  In that case, if `a` is signed then the</span>
<span class="sd">        platform integer is used while if `a` is unsigned then an unsigned</span>
<span class="sd">        integer of the same precision as the platform integer is used.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output, but the type of the output</span>
<span class="sd">        values will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `prod` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    product_along_axis : ndarray, see `dtype` parameter above.</span>
<span class="sd">        An array shaped as `a` but with the specified axis removed.</span>
<span class="sd">        Returns a reference to `out` if specified.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.prod : equivalent method</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.  That means that, on a 32-bit platform:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x)  # random</span>
<span class="sd">    16</span>

<span class="sd">    The product of an empty array is the neutral element 1:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([])</span>
<span class="sd">    1.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By default, calculate the product of all elements:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([1.,2.])</span>
<span class="sd">    2.0</span>

<span class="sd">    Even when the input array is two-dimensional:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])</span>
<span class="sd">    24.0</span>

<span class="sd">    But we can also specify the axis over which to multiply:</span>

<span class="sd">    &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)</span>
<span class="sd">    array([  2.,  12.])</span>

<span class="sd">    If the type of `x` is unsigned, then the output type is</span>
<span class="sd">    the unsigned platform integer:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x).dtype == np.uint</span>
<span class="sd">    True</span>

<span class="sd">    If `x` is of a signed integer type, then the output type</span>
<span class="sd">    is the default platform integer:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; np.prod(x).dtype == int</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">prod</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                          <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cumulative product of elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the cumulative product is computed.  By default</span>
<span class="sd">        the input is flattened.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type of the returned array, as well as of the accumulator in which</span>
<span class="sd">        the elements are multiplied.  If *dtype* is not specified, it</span>
<span class="sd">        defaults to the dtype of `a`, unless `a` has an integer dtype with</span>
<span class="sd">        a precision less than that of the default platform integer.  In</span>
<span class="sd">        that case, the default platform integer is used instead.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output</span>
<span class="sd">        but the type of the resulting values will be cast if necessary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cumprod : ndarray</span>
<span class="sd">        A new array holding the result is returned unless `out` is</span>
<span class="sd">        specified, in which case a reference to out is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">    raised on overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2</span>
<span class="sd">    ...               # total product 1*2*3 = 6</span>
<span class="sd">    array([1, 2, 6])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output</span>
<span class="sd">    array([   1.,    2.,    6.,   24.,  120.,  720.])</span>

<span class="sd">    The cumulative product for each column (i.e., over the rows) of `a`:</span>

<span class="sd">    &gt;&gt;&gt; np.cumprod(a, axis=0)</span>
<span class="sd">    array([[ 1,  2,  3],</span>
<span class="sd">           [ 4, 10, 18]])</span>

<span class="sd">    The cumulative product for each row (i.e. over the columns) of `a`:</span>

<span class="sd">    &gt;&gt;&gt; np.cumprod(a,axis=1)</span>
<span class="sd">    array([[  1,   2,   6],</span>
<span class="sd">           [  4,  20, 120]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of dimensions of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.  If it is not already an ndarray, a conversion is</span>
<span class="sd">        attempted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number_of_dimensions : int</span>
<span class="sd">        The number of dimensions in `a`.  Scalars are zero-dimensional.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.ndim : equivalent method</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ndim([[1,2,3],[4,5,6]])</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(np.array([[1,2,3],[4,5,6]]))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(1)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span>


<span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of dimensions of an array.</span>

<span class="sd">    If `a` is not already an array, a conversion is attempted.</span>
<span class="sd">    Scalars are zero dimensional.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is deprecated in NumPy 1.9 to avoid confusion with</span>
<span class="sd">        `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function</span>
<span class="sd">        should be used instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array whose number of dimensions is desired. If `a` is not an array,</span>
<span class="sd">        a conversion is attempted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number_of_dimensions : int</span>
<span class="sd">        The number of dimensions in the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndim : equivalent function</span>
<span class="sd">    ndarray.ndim : equivalent property</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the old Numeric package, `rank` was the term used for the number of</span>
<span class="sd">    dimensions, but in NumPy `ndim` is used instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.rank([1,2,3])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.rank(np.array([[1,2,3],[4,5,6]]))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.rank(1)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2014-04-12, 1.9</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;`rank` is deprecated; use the `ndim` attribute or function instead. &quot;</span>
        <span class="s2">&quot;To find the rank of a matrix see `numpy.linalg.matrix_rank`.&quot;</span><span class="p">,</span>
        <span class="n">VisibleDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span>


<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of elements along a given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the elements are counted.  By default, give</span>
<span class="sd">        the total number of elements.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    element_count : int</span>
<span class="sd">        Number of elements along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    shape : dimensions of array</span>
<span class="sd">    ndarray.shape : dimensions of array</span>
<span class="sd">    ndarray.size : number of elements in array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; np.size(a)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; np.size(a,1)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.size(a,0)</span>
<span class="sd">    2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">around</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evenly round to the given number of decimals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    decimals : int, optional</span>
<span class="sd">        Number of decimal places to round to (default: 0).  If</span>
<span class="sd">        decimals is negative, it specifies the number of positions to</span>
<span class="sd">        the left of the decimal point.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output, but the type of the output</span>
<span class="sd">        values will be cast if necessary. See `doc.ufuncs` (Section</span>
<span class="sd">        &quot;Output arguments&quot;) for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rounded_array : ndarray</span>
<span class="sd">        An array of the same type as `a`, containing the rounded values.</span>
<span class="sd">        Unless `out` was specified, a new array is created.  A reference to</span>
<span class="sd">        the result is returned.</span>

<span class="sd">        The real and imaginary parts of complex numbers are rounded</span>
<span class="sd">        separately.  The result of rounding a float is a float.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.round : equivalent method</span>

<span class="sd">    ceil, fix, floor, rint, trunc</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For values exactly halfway between rounded decimal values, NumPy</span>
<span class="sd">    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,</span>
<span class="sd">    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due</span>
<span class="sd">    to the inexact representation of decimal fractions in the IEEE</span>
<span class="sd">    floating point standard [1]_ and errors introduced when scaling</span>
<span class="sd">    by powers of ten.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] &quot;Lecture Notes on the Status of  IEEE 754&quot;, William Kahan,</span>
<span class="sd">           http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</span>
<span class="sd">    .. [2] &quot;How Futile are Mindless Assessments of</span>
<span class="sd">           Roundoff in Floating-Point Computation?&quot;, William Kahan,</span>
<span class="sd">           http://www.cs.berkeley.edu/~wkahan/Mindless.pdf</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.around([0.37, 1.64])</span>
<span class="sd">    array([ 0.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)</span>
<span class="sd">    array([ 0.4,  1.6])</span>
<span class="sd">    &gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value</span>
<span class="sd">    array([ 0.,  2.,  2.,  4.,  4.])</span>
<span class="sd">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned</span>
<span class="sd">    array([ 1,  2,  3, 11])</span>
<span class="sd">    &gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)</span>
<span class="sd">    array([ 0,  0,  0, 10])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrapfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Round an array to the given number of decimals.</span>

<span class="sd">    Refer to `around` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    around : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">around</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the arithmetic mean along the specified axis.</span>

<span class="sd">    Returns the average of the array elements.  The average is taken over</span>
<span class="sd">    the flattened array by default, otherwise over the specified axis.</span>
<span class="sd">    `float64` intermediate and return values are used for integer inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the means are computed. The default is to</span>
<span class="sd">        compute the mean of the flattened array.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a mean is performed over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the mean.  For integer inputs, the default</span>
<span class="sd">        is `float64`; for floating point inputs, it is the same as the</span>
<span class="sd">        input dtype.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">        See `doc.ufuncs` for details.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `mean` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : ndarray, see dtype parameter above</span>
<span class="sd">        If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">        otherwise a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    average : Weighted average</span>
<span class="sd">    std, var, nanmean, nanstd, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arithmetic mean is the sum of the elements along the axis divided</span>
<span class="sd">    by the number of elements.</span>

<span class="sd">    Note that for floating-point input, the mean is computed using the</span>
<span class="sd">    same precision the input has.  Depending on the input data, this can</span>
<span class="sd">    cause the results to be inaccurate, especially for `float32` (see</span>
<span class="sd">    example below).  Specifying a higher-precision accumulator using the</span>
<span class="sd">    `dtype` keyword can alleviate this issue.</span>

<span class="sd">    By default, `float16` results are computed using `float32` intermediates</span>
<span class="sd">    for extra precision.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a, axis=0)</span>
<span class="sd">    array([ 2.,  3.])</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a, axis=1)</span>
<span class="sd">    array([ 1.5,  3.5])</span>

<span class="sd">    In single precision, `mean` can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0, :] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1, :] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.mean(a)</span>
<span class="sd">    0.54999924</span>

<span class="sd">    Computing the mean in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.mean(a, dtype=np.float64)</span>
<span class="sd">    0.55000000074505806</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                          <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the standard deviation along the specified axis.</span>

<span class="sd">    Returns the standard deviation, a measure of the spread of a distribution,</span>
<span class="sd">    of the array elements. The standard deviation is computed for the</span>
<span class="sd">    flattened array by default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Calculate the standard deviation of these values.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the standard deviation is computed. The</span>
<span class="sd">        default is to compute the standard deviation of the flattened array.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a standard deviation is performed over</span>
<span class="sd">        multiple axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type to use in computing the standard deviation. For arrays of</span>
<span class="sd">        integer type the default is float64, for arrays of float types it is</span>
<span class="sd">        the same as the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output but the type (of the calculated</span>
<span class="sd">        values) will be cast if necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        Means Delta Degrees of Freedom.  The divisor used in calculations</span>
<span class="sd">        is ``N - ddof``, where ``N`` represents the number of elements.</span>
<span class="sd">        By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `std` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_deviation : ndarray, see dtype parameter above.</span>
<span class="sd">        If `out` is None, return a new array containing the standard deviation,</span>
<span class="sd">        otherwise return a reference to the output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    var, mean, nanmean, nanstd, nanvar</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The standard deviation is the square root of the average of the squared</span>
<span class="sd">    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.</span>

<span class="sd">    The average squared deviation is normally calculated as</span>
<span class="sd">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,</span>
<span class="sd">    the divisor ``N - ddof`` is used instead. In standard statistical</span>
<span class="sd">    practice, ``ddof=1`` provides an unbiased estimator of the variance</span>
<span class="sd">    of the infinite population. ``ddof=0`` provides a maximum likelihood</span>
<span class="sd">    estimate of the variance for normally distributed variables. The</span>
<span class="sd">    standard deviation computed in this function is the square root of</span>
<span class="sd">    the estimated variance, so even with ``ddof=1``, it will not be an</span>
<span class="sd">    unbiased estimate of the standard deviation per se.</span>

<span class="sd">    Note that, for complex numbers, `std` takes the absolute</span>
<span class="sd">    value before squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the *std* is computed using the same</span>
<span class="sd">    precision the input has. Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for float32 (see example below).</span>
<span class="sd">    Specifying a higher-accuracy accumulator using the `dtype` keyword can</span>
<span class="sd">    alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.std(a)</span>
<span class="sd">    1.1180339887498949</span>
<span class="sd">    &gt;&gt;&gt; np.std(a, axis=0)</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.std(a, axis=1)</span>
<span class="sd">    array([ 0.5,  0.5])</span>

<span class="sd">    In single precision, std() can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0, :] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1, :] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.std(a)</span>
<span class="sd">    0.45000005</span>

<span class="sd">    Computing the standard deviation in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.std(a, dtype=np.float64)</span>
<span class="sd">    0.44999999925494177</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">std</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the variance along the specified axis.</span>

<span class="sd">    Returns the variance of the array elements, a measure of the spread of a</span>
<span class="sd">    distribution.  The variance is computed for the flattened array by</span>
<span class="sd">    default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose variance is desired.  If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the variance is computed.  The default is to</span>
<span class="sd">        compute the variance of the flattened array.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If this is a tuple of ints, a variance is performed over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the variance.  For arrays of integer type</span>
<span class="sd">        the default is `float32`; for arrays of float types it is the same as</span>
<span class="sd">        the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output, but the type is cast if</span>
<span class="sd">        necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">        ``N - ddof``, where ``N`` represents the number of elements. By</span>
<span class="sd">        default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `var` method of sub-classes of</span>
<span class="sd">        `ndarray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-classes `sum` method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variance : ndarray, see dtype parameter above</span>
<span class="sd">        If ``out=None``, returns a new array containing the variance;</span>
<span class="sd">        otherwise, a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    std , mean, nanmean, nanstd, nanvar</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The variance is the average of the squared deviations from the mean,</span>
<span class="sd">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span>

<span class="sd">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span>
<span class="sd">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span>
<span class="sd">    instead.  In standard statistical practice, ``ddof=1`` provides an</span>
<span class="sd">    unbiased estimator of the variance of a hypothetical infinite population.</span>
<span class="sd">    ``ddof=0`` provides a maximum likelihood estimate of the variance for</span>
<span class="sd">    normally distributed variables.</span>

<span class="sd">    Note that for complex numbers, the absolute value is taken before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the variance is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32` (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.var(a)</span>
<span class="sd">    1.25</span>
<span class="sd">    &gt;&gt;&gt; np.var(a, axis=0)</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.var(a, axis=1)</span>
<span class="sd">    array([ 0.25,  0.25])</span>

<span class="sd">    In single precision, var() can be inaccurate:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; a[0, :] = 1.0</span>
<span class="sd">    &gt;&gt;&gt; a[1, :] = 0.1</span>
<span class="sd">    &gt;&gt;&gt; np.var(a)</span>
<span class="sd">    0.20250003</span>

<span class="sd">    Computing the variance in float64 is more accurate:</span>

<span class="sd">    &gt;&gt;&gt; np.var(a, dtype=np.float64)</span>
<span class="sd">    0.20249999932944759</span>
<span class="sd">    &gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2</span>
<span class="sd">    0.2025</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;keepdims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keepdims</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">mu</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">var</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_methods</span><span class="o">.</span><span class="n">_var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, gen/5.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>